## 第6章 函数
### 6.1 函数基础
**局部静态对象**
* 函数的局部变量在函数退出后被销毁，有些时候，希望在函数退出后该变量依旧存在，可以将局部变量定义为静态对象，用`static`修饰符修饰，该变量将在程序终止时才被销毁

**分离式编译**
* 函数声明为头文件中，定义在文件a中，文件b中调用了函数。当我们修改了该函数时，只需重新编译文件a，生成.obj(windows)或.o（UNIX）后缀的对象文件，编译器会将对象文件链接在一起形成可执行文件。

### 6.2 参数传递
* 函数中的参数传递方式有两种：引用传递和值传递
    * 引用传递中，形参是对应实参的别名，在函数内对形参的修改会影响实参
    * 值传递中，两者是相互独立的
* 使用引用形参，能够帮助函数返回额外的信息。
    * 如一个函数的功能是查找字符串str中是否包含字符'c'，若包含并计算出现次数，我们可以编写函数返回值为布尔值，一个参数为出现次数
* 使用引用形参时，如果在函数内不希望修改这个对象，请将该形参声明为常量形参
```
//fcn能够读取i，但是不能向i写值
void fcn(const int i ){}
```
* 数组形参
    * 向函数传递数组，实际上传递的是数组首元素的指针
    * 当传递参数是数组时，为了安全起见，需要告知数组的长度，以免函数内使用数据越界

* 含有可变形参的函数
  * 有时我们无法提前预知应该向函数传递几个实参，C++11提供了两种解决方法，一种方法如下，另一种见`16.4节`
  * initializer_list标准库，能够处理<font color="red">类型相同</font>的形参数量不确定的情况，使用方法如下：

  ```
  void error_msg(ErrorCode e, initializer_list<string> li)
  {
    std::cout << e.msg() << ": ";
    for(const auto &elem : li)
    {
      std::cout << li << " ";
    }
    std::cout << std::endl;
  }
  ```
  调用该函数的使用方法如下：
  ```
  error_msg(ErrorCode(42), {"functionX", expected, actual});
  ```

### 6.4 函数重载
* 若**同一个作用域内**，多个函数有相同的名字，但是形参列表不同（形参个数不同或形参类型不同），称这些函数为重载函数
* 编译器会根据实参明确调用哪个函数

### 6.5 特殊用途语言特性
* 用inline修饰函数，声明内联函数，通知编译器在编译时将函数展开，一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。 
