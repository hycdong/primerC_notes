## 第2章 变量和基本类型

### 2.1 基本内置类型
#### 2.1.1 算数类型（整型和浮点型）
* 算数类型包括整型（包括布尔，char）和浮点型
* 算术类型的尺寸在不同机器上有所差别，下面列出的是c++标准规定的最小值：

类型 | 含义 | 最小尺寸
:----:|:----:|:---:
bool | 布尔值 | 未定义
char | 字符型 | 8bit
int | 整型 | 16bit
long | 长整型 | 32bit
float | 单精度浮点数 | 6位有效数字（通常是4字节）
double | 双精度浮点数 | 10位有效数字（通常是8字节）

> 关于 **字节** 的说明：
在计算机中，可寻址的最小的内存块称为字节（byte），存储的基本单位是字（word），字由字节组成。大多数机器的字节是8bit，字通常4字节（32bit）或8字节（64bit）。

* 算数类型都有带符号和无符号

* 如何选择类型：
  * 当数值一定不为负时，选用无符号类型
  * 使用int执行整数运算
  * 算数表达式中不使用char或者bool
  * 浮点数计算首选double

#### 2.1.2 类型转换

* 隐式类型转换发生在条件判断等情况下，P33列出了部分转换原则

* 在混用带符号数和无符号数时，带符号数会隐式转换成无符号数，可能导致带符号数被编译器认为是一个很大的无符号数，因此应避免混用

#### 2.1.3 字面值常量

* 整型字面值，下面都是数值20
  * 20 十进制（带符号数，int、long、long long中能容纳该值的最小单位[最小为int]）
  * 024 八进制
  * 0x14 十六进制
* 浮点型字面值
  * 小数或者科学计数法表示的指数，如3.14159E0
  * 默认是double
* 字符字面值
  * 'a'
* 字符串字面值
  * 常量字符构成的数组，编译器会添加空字符'\0'
  * "A" - 字母A+空字符
* 转义序列
  * 不可打印的字符
  * 在c++中有特殊含义的字符（单引号，双引号，问号，反斜线）
* 布尔字面值和指针字面值

### 2.2 变量

* 变量的初始化和赋值不同，初始化的含义是创建变量时赋予其一个初始值，赋值的含义是把对象当前值擦除，而以一个新值来替代
* 列表初始化，例如为vector初始化多个值
* 建议初始化每个变量，使用未初始化的变量带来无法预计的后果
* C++声明与定义分离 `TODO:6.1.3节`
  * 声明使得名字为程序所知，定义则负责创建与名字关联的实体
  * 变量只能被定义一次，但是可以被多次声明
  * 若要**在多个文件中使用同一个变量，就必须将声明和定义分离**
  * 变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对它进行声明，但是不能重复定义
```
/*使用extern关键字可以只声明变量，而非定义它*/
  extern int i; //声明i，而非定义
  int j;        //声明并定义j
```
* 标识符（变量名）的命名规范
* 变量的作用域

### 2.3 复合类型
#### 2.3.1 引用（左值引用）

> 这里都指的是左值引用，C++11中引入了“右值引用”，见13.6.1

* 定义引用时，会把引用和它指向的对象绑定起来
* 引用不是对象，对引用的操作其实是对其指向的对象的操作
```
int ival = 1024;
int &refVal = ival; // refVal指向ival
int &refVal2;       // 报错，引用必须初始化
refval2 = 2;        // ival = 2
```

#### 2.3.2 指针

* 指针类型与引用不同，是对象
* void*存放着对象的地址，没办法访问内存，==见19.1.1==
* 建议在定义指针时初始化，用nullptr而非NULL

```
int i = 0;
int &r = i;     //r是一个引用
int *p;         //p是一个指针
p = &i;         //&出现在表达式中，是一个取地址符
*p = i;         //*出现在表达式中，是一个解引用符
int &r2 = *p;   //r2是引用，*是一个解引用符
```
#### 2.3.3 理解复合类型的声明

* 指向指针的指针与指向指针的引用

```
/*指向指针的指针*/
int i = 0;
int *pi = &i;
int **ppi = &pi;    //ppi是一个指向指针的指针

/*指向指针的引用*/
int i = 1122;
int *p;
int *&r = p;    //r是对指针p的引用
r = &i;         //令p指向i
*r = 0;         //将i的值改成0
```

> 从右向左阅读变量的定义便于理解变量的真实含义。
如上面r，离它最近的是&，因此r是一个引用，*说明r引用的是一个指针

### 2.4 const限定符
* 用关键字const修饰的变量将会被当作常量，在编译时会被替换为初始化时的值，之后不能再被修改
* 默认情况下，const对象只在文件内有效，若想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

```
extern const int bufSize;       //file.h中声明
extern const int bufSize = 512; //file.cc中定义并初始化常量，并能被其他文件当问
```

#### 2.4.1 const与引用
* 把引用绑定到常量上，称为对常量的引用，简称为**常量引用**

```
/*const与引用的示例*/
int i = 1;
const ic = 1;

const int &ric = ic;//正确
ric = 2;            //错误

const int &ri = i;  //正确，允许将const int&绑定到一个普通int对象上
ri = 2;             //错误，不能通过常量引用改变i的值

int &r = ic;        //错误，不允许将普通引用绑定到const对象上

```

#### 2.4.2 const与指针
* 指向常量的指针，因为指针指向的是常量，因此值不能改变

```
const double pic = 3.14;
double pi = 3.14;

const double *ptrc = &pic;  //正确
*ptrc = 3.14159;            //错误

const double *ptr = &pi;    //正确，允许指向非常量
*ptr = 3.14159;             //错误，不能通过ptr改变pi的值
```

* const指针，常量指针，存放指针的地址不变，值可以改变

```
int i = 0;
int *const pc = &i;    //正确
*pci = 1;               //正确

const double d = 3.14;
const double *const pcd = &d;   //正确，指向常量对象的常量指针
*pcd = 3.14159;                 //错误，不能修改常量对象的值
```

#### 2.4.3 顶层const与底层const

* 顶层const表示对象本身是常量，该对象的值不能改变，但顶层const的对象若是指针，则表示指针的地址不能改变，但是值可以改变
* 底层const表示指针所指向的对象是常量，这时指针指向的地址可以改变，指针的值不能改变，用于声明引用的const都是底层const
* 顶层和底层const在执行copy操作时有所不同
  * 顶层const执行copy时，拷入和拷出对象不要求是否是常量
  * 底层const执行copy时，拷入和拷出对象要求都是底层const，或能够互相转换

```
const int ic = 0;   //顶层const

int i = 0;
int *const pc = &i; //顶层const,pc不能改，i可以改

const int *p = &ic; //底层const，p可以改，ic不能改
const int &r = ic;  //底层const

const int *const pcc = p;   //既是顶层也是底层
```
#### 2.4.4 constexpt和常量表达式

* 常量表达式是值不会发生变化且在编译过程中能得到计算结果的表达式
* C++11 允许将变量声明为constexpt由编译器验证变量的值是否为常量表达式
```
constexpr int mf = 20;      //20是常量表达式
constexpr int limit = mf+1; //mf+1是常量表达式
constexpr int sz = size();  //当size函数是一个constexpt函数时才正确
```
* constexpr也可以修饰指针和引用，但初始值有限制。一个constexpr指针的初始值必须是nullptr，0，或者存储于某个固定地址的对象（函数内的变量一般地址不固定）
* 用constexpr声明指针会将它定义的对象置为顶层const，即常量指针

### 2.5 类型处理

#### 2.5.1 类型别名
* typedef关键字
```
typedef double wages, *p;  //wages是double的同义词，p是double*的同义词
```
* using关键字
```
using SI = Sales_item;  //SI是Sales_item的同义词
```
* 指针，const与typedef
  *  将类型别名替换为它本来的样子是错误的！
  *  例如下面例子中的cstr
     * pstring是类型，指向char的指针，const是对类型的修饰，因此cstr是**常量指针**
     * 若直接替换，理解为 const char *cstr = 0;
       * 数据类型就不是指针了，而是char，含义为指向常量char的指针

```
typedef char *pstring;
const pstring cstr = 0; //cstr是指向char的常量指针
```

#### 2.5.2 auto
* C++11中引入了auto类型说明符，让编译器替我们分析表达式所属的类型
* 一条声明语句的初始数据类型应保持一致

```
auto i = 0, *p = &i;    //i是int，p是int指针
auto sz = 0, pi = 3.14; //错误，sz和pi类型不同
```
* auto与引用，const
  * 用auto声明引用，auto的类型为引用的实际类型
  * auto会忽略顶层const，保留底层const

```
int i = 0, &r = i;
auto a = r;         //a是int

const int ci = 0, &cr = ci;
auto b = ci;        //b是int,ci是顶层const
auto c = cr;        //c是int，ci是顶层const
auto d = &i;        //d是int指针
auto e = &ci;       //e是指向const int的指针（&ci是底层const）
```

#### 2.5.3 decltype
* C++11引入decltype类型说明符，解决希望从表达式的类型推断出要定义的类型
* 若表达式是函数，则返回函数的返回值类型，并且不真正调用函数
* 若表达式是变量，则返回该变量的类型，包括引用和顶层const
* 若是其他普通表达式，则返回表达式结果对应的类型
* 若是解引用符或者双层括号，则返回引用类型

```
//函数
decltype(f()) sum = x;  //sum的类型是f函数返回值的类型

//变量
const int ci = 0, &cr = ci;
decltype(ci) x = 0;     //x是const int
decltype(cr) y = x;     //y是引用类型，y绑定到x

//表达式
int i = 42, *p = &i, &r = i;
decltype(r+0) b;        //正确，加法的结果是int，b是一个未初始化的int
decltype(*p) c;         //错误，解引用符是引用类型，int&，必须初始化
decltype((i)) d;        //错误，双层括号是引用类型，int&，必须初始化
decltype(i) e;          //正确，e是的类型int
```

### 2.6 自定义数据结构
* 可以使用struct自定义类型，与class的区别见 `第7章`
* 自定义头文件
  * 类的成员变量，const，constexpr类型的变量一般都定义在头文件中
  * 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明
  * 头文件的引用有时会有多次引用，要使用预处理变量
    * #define，#ifdef，#ifndef,#endif
